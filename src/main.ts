import { canvas, canvasContext } from './browser/browserElements'
import { Bot } from './classes/bot'
import { Boundary } from './classes/boundary'
import {
  boundaries,
  gridSquares,
  randomSpotOnMap
} from './components/arena'
import {
  botMovement,
  circleCollideWithReactangle,
  getRandomSpeed
} from './utils/collitions'

/* ============= constants ============= */

const colors = ['blue', 'yellow', 'red', 'violet', 'green', 'lightBlue', 'gray']

// this array will hold all the bots
const bots: Bot[] = []

/*
  animationID will contain the frame (a number) generated by the 'requestAnimationFrame'

  it's fair to said that the requestAnimationFrame is the responsable of the animations, that's why the
    requestAnimationFrame is called in the animate function

  this number is also used by the 'cancelAnimationFrame' to stop the animations
*/
let animationID: number

/* ============== Create Bots ============== */

function generateBots (botsNum = 4): void {
  // the foor loop it's just for create more than one bot
  for (let i = 0; i < botsNum; i++) {
    // random spot on map return a random coordinates (x,y) in the map
    const spot = randomSpotOnMap()
    // getRandomSpeed return an object with are the velocities in the x and y axis
    const initialSpeed = getRandomSpeed()

    // here we create a new instance of the bot class (our bot)
    const bot = new Bot({
      position: {
        x: Boundary.width * spot.x + (Boundary.width / 2), // initial position of the bot in x-axis
        y: Boundary.height * spot.y + (Boundary.height / 2) // initial position of the bot in x-axis
      },
      velocity: {
        x: initialSpeed.x,
        y: initialSpeed.y
      },
      color: colors[i]
    })

    bots.push(bot) // finally, add the new bot to the array of bots
  }
}

/* ============== function Animate =============== */

function animate (): void {
  animationID = window.requestAnimationFrame(animate)
  // we clear the canvas to prevent mixing new and old animations
  canvasContext.clearRect(0, 0, canvas.width, canvas.height)

  // grid squares contain instances of the GridSquare class, each instance has a method called draw to draw the square in the map
  gridSquares.forEach(square => { square.draw() })

  // TODO: place here the function to detect collision beteween bots

  // we do something similar as with gridSquare, but a little different
  bots.forEach((bot) => {
    // we need to check if the bot is colliding with a boundary
    boundaries.forEach((boundary) => {
      // At the same time, we take the opportunity to draw all the borders
      boundary.draw()

      // if the bot collide with the boundary, stop the bot (the bot velocity in both axis = 0)
      botCollideWithBoundary(bot, boundary)
    })

    // The bot has to move
    botMovement(bot, boundaries)

    // Finally, update the status of the bot and draw it on the map
    bot.update()
  })
}

function botCollideWithBoundary (bot: Bot, boundary: Boundary): void {
  // mechanics of a collition between a circle (the bot) and square (our boundary)
  if (circleCollideWithReactangle({
    circle: bot,
    rectangle: boundary
  })) {
    bot.velocity.y = 0 // if they collide, stop the movement of the bot
    bot.velocity.x = 0 // if this is not here, the bot continues his path to nowhere
  }
}

// this start and end the animation
// the reason for having both elements in one function is to give the bot the 'jump effect'
function animationLoop (): void {
  // this draw everything on the map
  animate()
  // this stop all the animation
  window.cancelAnimationFrame(animationID)
}

// call the animation loop every x amount of time (in this case 300 ms)
window.setInterval(() => { animationLoop() }, 300)

// amount of bot generates, in this case 1 (default = 4)
generateBots(1)
